package com.tcl.database;

import com.tcl.bean.MessageUtils;
import com.tcl.bean.MsgExtraContent;
import com.tcl.utils.CaculateUtil;
import com.tcl.utils.LogExt;

import java.nio.ByteBuffer;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END

/**
 * Entity mapped to table "MSG".
 */
public class Msg {

    private Long id;
    /**
     * Not-null value.
     */
    private String _UserUID;
    private long _Timestamps;
    private int _Type;
    private Integer _SendType;
    private Integer _CRC8;
    private byte[] _Bytes;
    private Integer _Length;
    private Integer _SendTime;

    /**
     * Used to resolve relations
     */
    private transient DaoSession daoSession;

    /**
     * Used for active entity operations.
     */
    private transient MsgDao myDao;


    // KEEP FIELDS - put your custom fields here
    private static final String TAG = "fuyao-Msg";

    private ByteBuffer mByteBuffer = null;

    MsgExtraContent mMsgExtraContent = new MsgExtraContent();
    // KEEP FIELDS END

    public Msg() {
    }

    public Msg(Long id, byte[] _Bytes) {
        this.id = id;
        this._Bytes = _Bytes;
    }

    public Msg(Long id, String _UserUID, long _Timestamps, int _Type, Integer _SendType, Integer _CRC8, byte[] _Bytes, Integer _Length, Integer _SendTime) {
        this.id = id;
        this._UserUID = _UserUID;
        this._Timestamps = _Timestamps;
        this._Type = _Type;
        this._SendType = _SendType;
        this._CRC8 = _CRC8;
        this._Bytes = _Bytes;
        this._Length = _Length;
        this._SendTime = _SendTime;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMsgDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Not-null value.
     */
    public String get_UserUID() {
        return _UserUID;
    }

    /**
     * Not-null value; ensure this value is available before it is saved to the database.
     */
    public void set_UserUID(String _UserUID) {
        this._UserUID = _UserUID;
    }

    public long get_Timestamps() {
        return _Timestamps;
    }

    public void set_Timestamps(long _Timestamps) {
        this._Timestamps = _Timestamps;
    }

    public int get_Type() {
        return _Type;
    }

    public void set_Type(int _Type) {
        this._Type = _Type;
    }

    public Integer get_SendType() {
        return _SendType;
    }

    public void set_SendType(Integer _SendType) {
        this._SendType = _SendType;
    }

    public Integer get_CRC8() {
        return _CRC8;
    }

    public void set_CRC8(Integer _CRC8) {
        this._CRC8 = _CRC8;
    }

    public byte[] get_Bytes() {
        return _Bytes;
    }

    public void set_Bytes(byte[] _Bytes) {
        this._Bytes = _Bytes;
    }

    public Integer get_Length() {
        return _Length;
    }

    public void set_Length(Integer _Length) {
        this._Length = _Length;
    }

    public Integer get_SendTime() {
        return _SendTime;
    }

    public void set_SendTime(Integer _SendTime) {
        this._SendTime = _SendTime;
    }

    /**
     * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
     */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.delete(this);
    }

    /**
     * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
     */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.update(this);
    }

    /**
     * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
     */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here

    public void setDstUser(User u) {
        mMsgExtraContent.setDstUser(u);
    }

    public void setSrcUser(User u) {
        mMsgExtraContent.setSrcUser(u);
    }

    public User getSrcUser() {
        return mMsgExtraContent.getSrcUser();
    }

    public User getDstUser() {
        return mMsgExtraContent.getDstUser();
    }

    public int getExtraReturnCrc8() {
        return mMsgExtraContent.getExtraReturnCrc8();
    }

    public void setExtraReturnCrc8(int crc8) {
        mMsgExtraContent.setExtraReturnCrc8(crc8);
    }

    public ByteBuffer getByteBuffer() {
        return mByteBuffer;
    }

    public int getPort() {
        return mMsgExtraContent.getPort();
    }

    public void setPort(int port) {
        mMsgExtraContent.setPort(port);
    }

    public String getDstAddress() {
        return mMsgExtraContent.getDstUser().get_IpAddress();
    }

    public void addSendTime() {
        _SendTime++;
    }

    // will wirte crc8,dstip,srcip,type,time,
    public final int productSendMsg() {
        mMsgExtraContent.productExtra(_Type, mByteBuffer, this);
        mByteBuffer.position(MessageUtils.LENGTH_BYTE_OFFSET);
        mByteBuffer.put(CaculateUtil.bigIntToByte(get_Length(), MessageUtils.LENGTH_BYTE_SIZE));
        mByteBuffer.position(MessageUtils.IP_SRC_BYTE_OFFSET);
        mByteBuffer.put(mMsgExtraContent.getSrcUser().get_IpAddress().getBytes());
        mByteBuffer.position(MessageUtils.IP_DST_BYTE_OFFSET);
        mByteBuffer.put(mMsgExtraContent.getDstUser().get_IpAddress().getBytes());
        mByteBuffer.position(MessageUtils.TYPE_BYTE_OFFSET);
        mByteBuffer.put(CaculateUtil.bigIntToByte(get_Type(), MessageUtils.TYPE_BYTE_SIZE));
        mByteBuffer.position(MessageUtils.TIME_BYTE_OFFSET);
        mByteBuffer.put(CaculateUtil.long2Byte(get_Timestamps()));
        mByteBuffer.position(MessageUtils.LENGTH_BYTE_OFFSET);
        byte[] temps = new byte[get_Length()];
        mByteBuffer.get(temps);
        set_CRC8(CaculateUtil.caculateCRC8(temps, 0, temps.length - 1));
        mByteBuffer.position(MessageUtils.CRC8_BYTE_OFFSET);
        mByteBuffer.putInt(get_CRC8());
        mByteBuffer.position(get_Length());
        mByteBuffer.flip();
        LogExt.d(TAG, "productMsg: " + this);
        return MessageUtils.PRODUCT_MSG_OK;
    }


    // receive buffer base
    // #length-4###CRC8-4####IP_S-32###IP_D-32####type-1####time-8##
    // |_________|_________|_________|__________|_________|_________|
    public final int parseBuffer(ByteBuffer buffer) {
        int ret = MessageUtils.PARSE_RESULT_DATA_ERROR;
        if (null != buffer) {
            int scrLength = buffer.limit();
            if (scrLength > 4) {
                byte[] msgs = new byte[scrLength];
                buffer.get(msgs);
                LogExt.d(TAG, LogExt.bytesToHexString(msgs));
                _Length = CaculateUtil.bigBytesToInt(msgs);
                if (get_Length() > scrLength) {
                    ret = MessageUtils.PARSE_RESULT_DATA_NOT_ENOUGH;
                } else {
                    int CRC8 = CaculateUtil.bigBytesToInt(msgs, MessageUtils.CRC8_BYTE_OFFSET);
                    msgs[MessageUtils.CRC8_BYTE_OFFSET] = 0;
                    msgs[MessageUtils.CRC8_BYTE_OFFSET + 1] = 0;
                    msgs[MessageUtils.CRC8_BYTE_OFFSET + 2] = 0;
                    msgs[MessageUtils.CRC8_BYTE_OFFSET + 3] = 0;
                    int tempCRC8 = CaculateUtil.caculateCRC8(msgs, MessageUtils.LENGTH_BYTE_OFFSET, msgs.length - 1);
                    if (CRC8 == tempCRC8) {
                        User srcUser = new User();
                        srcUser.set_IpAddress(new String(msgs, MessageUtils.IP_SRC_BYTE_OFFSET, MessageUtils.IP_SCR_BYTE_SIZE).trim());
                        mMsgExtraContent.setSrcUser(srcUser);

                        User dstUser = new User();
                        dstUser.set_IpAddress(new String(msgs, MessageUtils.IP_DST_BYTE_OFFSET, MessageUtils.IP_DST_BYTE_SIZE).trim());
                        mMsgExtraContent.setDstUser(dstUser);

                        _Type = msgs[MessageUtils.TYPE_BYTE_OFFSET];
                        _Timestamps = CaculateUtil.bytes2long(msgs, MessageUtils.TIME_BYTE_OFFSET);
                        ret = mMsgExtraContent.parseExtra(_Type, scrLength, msgs);
                    } else {
                        ret = MessageUtils.PARSE_RESULT_DATA_ERROR;
                    }
                }
            } else {
                ret = MessageUtils.PARSE_RESULT_DATA_NOT_ENOUGH;
            }
        } else {
            ret = MessageUtils.PARSE_RESULT_DATA_ERROR;
        }
        LogExt.d(TAG, "parseBuffer return " + MessageUtils.coverParseResult2String(ret));
        return ret;
    }

    //compare msg's bytes, if is same, return >0, else return < 0
    public int compare(Msg msg) {
        if (null == msg) {
            return -1;
        } else {
            byte[] tempBytes = msg.get_Bytes();
            if (null != tempBytes && null != _Bytes) {
                int tempLength = tempBytes.length;
                if (tempLength == _Length) {
                    for (int i = 0; i < tempLength; i++) {
                        if (tempBytes[i] != _Bytes[i]) return -4;
                    }
                } else {
                    return -3;
                }
            } else {
                return -2;
            }
        }
        return 1;
    }
    // KEEP METHODS END

}
